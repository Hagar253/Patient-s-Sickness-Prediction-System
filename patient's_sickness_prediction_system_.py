# -*- coding: utf-8 -*-
"""Patient's Sickness Prediction System .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qsC7DEoqFeQbroJZWWWmun9aTm6HKhp9
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
from pandas import DataFrame as df
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
import matplotlib
from numpy import reshape
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import scale
from sklearn import decomposition
from sklearn.manifold import TSNE
from sklearn.model_selection import train_test_split
# %matplotlib inline
plt.style.use('seaborn')
from sklearn import decomposition
import seaborn as sns
sns.set('notebook', font_scale=1.25, style='whitegrid')

heart=pd.read_csv("/content/Heart.csv")# to import data
heart

heart.isnull().sum()# to see if there is incompleted data
heart.info()

"""
***PCA***"""

pca=decomposition.PCA(n_components=2)# it is the number of variables we want to be
pca.fit(heart)# to fit heart data to model
print(f'Total number of components used after PCA : {pca.n_components_}')#to print number of components used for pca

train = pca.transform(heart)# we apply dimensionality reduction on heart data
print(f'train shape : {train.shape}')# to print the train shaped data
label=heart['AHD']# we make our label to see data be the AHD if there is heart attack or not
df=pd.DataFrame()# to visualize data by data frames
df["y"]=label # we make our y as label
df["comp-1"]=train[:,0]# our first priniciple component in pca data will be the first colume in data
df["comp-2"]=train[:,1]# our second priniciple component in pca data will be the second colume in data
sns.scatterplot(x="comp-1",y="comp-2",hue=df.y.tolist(),palette=sns.color_palette("hls",2),data=df).set(title="PCA") # we visualize data by scatter plot

"""***t_sne***"""

tsne = TSNE(n_components=2, perplexity=25,verbose=3, random_state=123)# we have change perplexity to be 25 to make the same points in same color becomes far from all data to appears more
z = tsne.fit_transform(heart)# we will take the heart data and fit,transform it
df = pd.DataFrame()
df["y"] = label
df["comp-1"] = z[:,0]# our first priniciple component in heart data will be the first colume in data after doing fit_transform
df["comp-2"] = z[:,1]# our second priniciple component in heart data will be the second colume in data after doing fit_transform

sns.scatterplot(x="comp-1", y="comp-2", hue=df.y.tolist(),
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" T-SNE projection on HEART DATA")

tsne = TSNE(n_components=2,perplexity=15, verbose=1, random_state=123)# we have change perplexity to be 15 to make the same points in same color becomes far from all data to appears more
z_pca = tsne.fit_transform(train)# we take the data we use in pca 'train' and we will transform and fit it
df = pd.DataFrame()
df["y"] = label
df["comp-1"] = z_pca[:,0]
df["comp-2"] = z_pca[:,1]
sns.scatterplot(x="comp-1", y="comp-2", hue=df.y.tolist(),
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" T-SNE projection on PCA")

"""***Kmeans***

***kmeans on pca data***
"""

kmeans=KMeans(2,random_state=0)# to do kmeans , we called bulit in function kMeans and give it number of clusters 2 and random state 0
kmeans.fit(train)# we fit train data from pca to kmeans
labels=kmeans.labels_# we make the labels for each point of kmeans
df = pd.DataFrame()
df["y"] = labels
df["comp-1"] = train[:,0]# our first priniciple component in pca data will be the first colume in train data
df["comp-2"] = train[:,1]# our second priniciple component in pca data will be the second colume in train data
sns.scatterplot(x="comp-1", y="comp-2", hue=labels,
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" Kmeans on pca data")

"""***kmeans on tsne on pca data***"""

kmeans_data=KMeans(2,random_state=0)#to do kmeans , we called bulit in function kMeans and give it number of clusters 2 and random state 0
kmeans_data.fit(z_pca)# we fit the data from tsne on pca data
labels_data=kmeans_data.labels_
df = pd.DataFrame()
df["y"] = labels_data
df["comp-1"] = z_pca[:,0]
df["comp-2"] = z_pca[:,1]
sns.scatterplot(x="comp-1", y="comp-2", hue=labels_data,
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" kmeans on tsne on pca data")

"""**kmeans on tsne heart data**"""

kmeans_data=KMeans(2,random_state=0)
kmeans_data.fit(z)# we fit data from tsne on heart data
labels_data=kmeans_data.labels_
df = pd.DataFrame()
df["y"] = labels_data
df["comp-1"] = z[:,0]
df["comp-2"] = z[:,1]
sns.scatterplot(x="comp-1", y="comp-2", hue=labels_data,
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" kmeans on tsne on heart data")

"""**kmeans on original data**"""

kmeans=KMeans(2,random_state=0)
h = kmeans.fit_transform(heart)# we compute clustering and transform heart data to cluster distance space to be able to plot it
labels=kmeans.labels_
df = pd.DataFrame()
df["y"] = labels
df["comp-1"] = h[:,0]
df["comp-2"] = h[:,1]
sns.scatterplot(x="comp-1", y="comp-2", hue=labels,
                palette=sns.color_palette("hls", 2),
                data=df).set(title=" Kmeans on heart data")